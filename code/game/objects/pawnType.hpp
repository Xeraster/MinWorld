pawnType :: pawnType()
{

}

pawnType :: pawnType(XMLElement *thingElement, SDL_Renderer *ren)
{

    m_defname = thingElement->FirstChildElement("defName")->GetText();
    m_label = thingElement->FirstChildElement("label")->GetText();
    m_description = thingElement->FirstChildElement("description")->GetText();

    m_minTemp = stof(thingElement->FirstChildElement("minTemp")->GetText());
    m_maxTemp = stof(thingElement->FirstChildElement("maxTemp")->GetText());
    m_minComfortableTemp = stof(thingElement->FirstChildElement("minComfortableTemp")->GetText());
    m_maxComfortableTemp = stof(thingElement->FirstChildElement("maxComfortableTemp")->GetText());
    m_fertility = stof(thingElement->FirstChildElement("fertility")->GetText());

    //todo: genders. there can be as many xml definable genders as you want, take a look at the xml pawnType for the cattoid/catbounce for example

    m_nutritionPerDay = stof(thingElement->FirstChildElement("nutritionPerDay")->GetText());
    m_moveSpeed = stof(thingElement->FirstChildElement("moveSpeed")->GetText());
    m_dirtiness = stof(thingElement->FirstChildElement("dirtiness")->GetText());
    m_growthRate = stof(thingElement->FirstChildElement("growthRate")->GetText());
    m_carryCapacity = stof(thingElement->FirstChildElement("carryingCapacity")->GetText());
    m_lifespan = stof(thingElement->FirstChildElement("lifespan")->GetText());
    //dietDef *m_dietDef;//diet restriction.
    m_nocturnal = stringToBool(thingElement->FirstChildElement("nocturnal")->GetText());

    m_marketValue = atof(thingElement->FirstChildElement("marketValue")->GetText());
    m_hitPoints = atoi(thingElement->FirstChildElement("hitPoints")->GetText());
    m_flammability = atof(thingElement->FirstChildElement("flammability")->GetText());
    m_techLevel = atoi(thingElement->FirstChildElement("techLevel")->GetText());

    //the armor system is similar to rimworld.
    m_armorSharp = atof(thingElement->FirstChildElement("armorSharp")->GetText());
    m_armorBlunt = atof(thingElement->FirstChildElement("armorBlunt")->GetText());
    m_armorHeat = atof(thingElement->FirstChildElement("armorHeat")->GetText());
    m_armorStink = atof(thingElement->FirstChildElement("armorStink")->GetText());//smells can be weaponized
    m_stinkTolerance = atof(thingElement->FirstChildElement("stinkTolerance")->GetText());

    /*harvest products
    if the harvest product variable has a nonzero value, autogenerate it
    */
    m_harvestLeather = stoi(thingElement->FirstChildElement("harvestLeather")->GetText());
    m_harvestFur = stoi(thingElement->FirstChildElement("harvestFur")->GetText());
    m_harvestMeat = stoi(thingElement->FirstChildElement("harvestMeat")->GetText());
    m_harvestBone = stoi(thingElement->FirstChildElement("harvestBone")->GetText());

    //the mask colors for the autogenerated harvest products
    m_furColor = color(thingElement->FirstChildElement("furColor")->GetText());
    m_skinColor = color(thingElement->FirstChildElement("skinColor")->GetText());
    m_meatColor = color(thingElement->FirstChildElement("meatColor")->GetText());
    m_boneColor = color(thingElement->FirstChildElement("boneColor")->GetText());

    //time for the texture stuff
    m_maskInFront = stringToBool(thingElement->FirstChildElement("maskInFront")->GetText());

    string textureFolder = thingElement->FirstChildElement("texture_folder")->GetText();
    string texturePrefix = thingElement->FirstChildElement("texture_prefix")->GetText();

    //generate filenames and see if it works
    //cout << "tex: " << textureFolder << "/" << texturePrefix << "_front.png" << endl;

    m_frontTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_front.png", ren);
    m_frontMaskTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_front_mask.png", ren);

    m_backTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_back.png", ren);
    m_backMaskTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_back_mask.png", ren);

    m_sideATex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_sideA.png", ren);
    m_sideAMaskTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_sideA_mask.png", ren);

    m_sideBTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_sideB.png", ren);
    m_sideBMaskTex = loadTextureToRam("Textures/" + textureFolder + "/" + texturePrefix + "_sideB_mask.png", ren);

    //if the pawn has a valid list of needs, load each of them
    if (thingElement->FirstChildElement("needs") != nullptr && thingElement->FirstChildElement("needs")->FirstChildElement("li") != nullptr)
    {
        //leave debug tests like this in during loading to make troubleshooting problems easier
        cout << m_defname << " has a list of needs" << endl;

        XMLElement *li = thingElement->FirstChildElement("needs")->FirstChildElement("li");
        while (li != nullptr)
        {
            //cout << "li = " << li->GetText() << endl;
            needType *t = GetNeedTypeByDefName(li->GetText());
            m_pawnNeeds.push_back(t);
            li = li->NextSiblingElement("li");
        }

        cout << "finished adding " << m_pawnNeeds.size() << " needs to " << m_defname << endl;

    }

    //print null textures to console for debugging purposes
    //printNullTextures();
    //works as expected: nonpresent textures remain nullptr after trying to load them. 

    /*there are 3 supported texture configurations:
        1. using just the front. In this configuration, you only supply the front (and mask, if desired). The game engine will rotate that 1 sprite for you
        2. supplying a front, back and sideA texture. The game engine will use sideA for both left and right facing and flip it automatically. Make sure sideA faces left. mask textures are supported and optional
        3. supplying a front, back, sideA and sideB texture. sideA is the left facing one. sideB is the back facing one. mask textures are supported and optional
    */

   //not setting up your textures using 1 of the 3 allowed scenarios causes indefined behavior but not neccesarily a crash. tl;dr rtfm
   if (m_sideATex != nullptr && m_sideBTex != nullptr)
   {
    m_textureConfiguration = 3;
   }
   else if (m_sideATex != nullptr)
   {
    m_textureConfiguration = 2;
   }
   else
   {
    m_textureConfiguration = 1;
   }

}
//true if the pawn has a valid list of needs. false if otherwise
bool pawnType :: hasNeeds() const
{
    if (m_pawnNeeds.size() == 0)
    {
        return false;
    }
    else
    {
        return true;
    }
}

//load everything in Data/PawnTypes/*
void loadAllPawnTypes(SDL_Renderer *ren)
{
    string dataPath = "Data/PawnTypes";
    vector<string> filePaths;

    for (const auto & entry : std::filesystem::directory_iterator(dataPath))
	{
        //load everything xml or not because fuck the feds
        std::cout << entry.path() << std::endl;
        filePaths.push_back(entry.path());
	}

    for (int i = 0; i < filePaths.size(); i++)
    {
        XMLDocument doc;
        doc.LoadFile(filePaths.at(i).c_str());

        if (doc.RootElement() == nullptr)
	    {
		    cout << "warning: a thing type xml file with no root element got loaded for some reason" << endl;
	    }


        //contents of all def xml files are supposed to be surrounded by def tags
        XMLElement *rootElement = doc.RootElement();
        XMLElement *thingToLoad = rootElement->FirstChildElement("PawnType");
        while (thingToLoad != nullptr)
        {
            pawnType newPawnType(thingToLoad, ren);
            pawnTypeDatabase.push_back(newPawnType);

            thingToLoad = thingToLoad->NextSiblingElement("PawnType");
            //cout << "loading" << endl;
        }
    }
}

SDL_Texture* pawnType :: getTextureByRotation(double rot)
{
    //if back texture is null, the pawn is using texture mode 1
    if (m_backTex == nullptr)
    {
        return m_frontTex;
    }

    //ugh
    //if rotation is north, pawn texture is mode 2 or 3
    if (rot < 45 || rot > 315)
    {
        return m_frontTex;
    }

    else if (rot >= 45 && rot < 135)
    {
        if (m_sideBTex != nullptr)
        {
            return m_sideBTex;
        }
        else if (m_sideATex != nullptr)
        {
            return m_sideATex;
        }
        else
        {
            //show the error texture?
            return nullptr;
        }
    }

    else if (rot >= 135 && rot < 225)
    {
        return m_backTex;
    }

    else if (rot >= 225 && rot < 315)
    {
        return m_sideATex;
    }

    //if it got here for some reason return nullptr
    return nullptr;
}

SDL_Texture* pawnType :: getMaskByRotation(double rot)
{
    //if back texture is null, the pawn is using texture mode 1
    if (m_backTex == nullptr)
    {
        return m_frontMaskTex;
    }

    //ugh
    //if rotation is north, pawn texture is mode 2 or 3
    if (rot < 45 || rot > 315)
    {
        return m_frontMaskTex;
    }

    else if (rot >= 45 && rot < 135)
    {
        if (m_sideBMaskTex != nullptr)
        {
            return m_sideBMaskTex;
        }
        else if (m_sideAMaskTex != nullptr)
        {
            return m_sideAMaskTex;
        }
        else
        {
            //show the error texture?
            return nullptr;
        }
    }

    else if (rot >= 135 && rot < 225)
    {
        return m_backMaskTex;
    }

    else if (rot >= 225 && rot < 315)
    {
        return m_sideAMaskTex;
    }

    //if it got here for some reason return nullptr
    return nullptr;
}

//if there are any nullptr textures, print them to the console. that's all this does and probably isn't whatever it is you're looking for
void pawnType :: printNullTextures()
{
    //front
    if (m_frontTex == nullptr)
    {
        cout << "m_frontTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    if (m_frontMaskTex == nullptr)
    {
        cout << "m_frontMaskTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    //back
    if (m_backTex == nullptr)
    {
        cout << "m_backTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    if (m_backMaskTex == nullptr)
    {
        cout << "m_backMaskTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    //sideA
    if (m_sideATex == nullptr)
    {
        cout << "m_sideATex on pawnType " << m_defname << " is nullptr " << endl;
    }

    if (m_sideAMaskTex == nullptr)
    {
        cout << "m_sideAMaskTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    //sideB

    if (m_sideBTex == nullptr)
    {
        cout << "m_sideBTex on pawnType " << m_defname << " is nullptr " << endl;
    }

    if (m_sideBMaskTex == nullptr)
    {
        cout << "m_sideBMaskTex on pawnType " << m_defname << " is nullptr " << endl;
    }
}

//copy pasted from the other similar functions, it'll probably work
pawnType *getPawnTypeByDefName(string name)
{
    bool foundMatch = false;
    int i = 0;
	while (!foundMatch)
	{
        if (pawnTypeDatabase.at(i).defname() == name)
        {
			foundMatch = true;
		}
		else
		{
			i++;
		}
	}

	return &pawnTypeDatabase.at(i);
}